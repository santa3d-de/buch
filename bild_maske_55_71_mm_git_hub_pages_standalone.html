<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coverdesigner für das Hörbuch für dein Hörspielbox</title>
  <meta name="description" content="Bild in mehreren mm-Rahmen laden, verschieben/zoomen und als PNG oder PDF exportieren. Perfekt für GitHub Pages (keine Build-Tools)." />
  <style>
    :root { --bg:#f7f7f8; --fg:#111; --muted:#666; --card:#fff; --border:#dcdcdc; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:var(--bg); color:var(--fg); }
    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 22px; margin: 0 0 8px; }
    p.lead { color: var(--muted); font-size: 14px; margin: 0 0 24px; }
    .grid { display: grid; grid-template-columns: 300px 1fr; gap: 16px; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 16px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
    .label { font-size: 12px; font-weight: 600; display: block; margin-bottom: 6px; }
    input[type="file"] { width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border); background: #fff; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row + .row { margin-top: 8px; }
    .btn { appearance: none; border: 1px solid var(--border); background: #fff; padding: 10px 12px; border-radius: 10px; cursor: pointer; font-size: 14px; }
    .btn:hover { background: #f2f2f2; }
    .btn:active { transform: translateY(1px); }
    .hint { color: var(--muted); font-size: 12px; }
    .frameList { display: grid; gap: 16px; }
    .frameTitle { font-size: 13px; font-weight: 600; margin-bottom: 8px; }
    .previewShell { border: 1px solid var(--border); margin: 0 auto; position: relative; overflow: hidden; background:#fff; border-radius: 10px; touch-action: none; cursor: default; }
    canvas { position:absolute; inset:0; width:100%; height:100%; }
    .drop { position:absolute; inset:0; display:grid; place-content:center; color:#777; font-size: 13px; text-align:center; padding: 0 12px; }
    .controlBlock { margin-top: 12px; }
    .buttonRow { flex-wrap: wrap; justify-content: flex-start; margin-top: 12px; }
    .buttonRow .btn { flex: 1 1 140px; }
  </style>
  <!-- jsPDF für PDF-Export (CDN) -->
  <script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>Coverdesigner für das Hörbuch für dein Hörspielbox</h1>
    <p class="lead">Bild hochladen, im gewünschten Millimeter-Rahmen verschieben/zoomen und als <strong>PDF</strong> (millimetergenau) oder <strong>PNG</strong> exportieren. Jeder Rahmen merkt sich eigene Position und Zoom. Beim Drucken in 100 % / „Tatsächliche Größe“ ohne „An Seite anpassen“ drucken.</p>

    <div class="grid">
      <!-- Linke Spalte: Steuerung -->
      <div class="card">
        <label class="label">Bild für alle Masken wählen</label>
        <input id="fileInput" type="file" accept="image/*" />
        <p class="hint" style="margin-top:12px">Tipp: Jede Maske kann ein eigenes Bild bekommen. Bild in der Vorschau anklicken und ziehen (auch Touch). Mit dem Mausrad zoomst du jeweils um den Zeiger herum.</p>
        <button id="exportAllPdf" class="btn" style="width:100%; margin-top:16px;" disabled>Alle 3 Masken als eine PDF exportieren</button>
      </div>

      <!-- Rechte Spalte: Vorschauen -->
      <div class="frameList">
        <div class="card frameCard">
          <div class="frameTitle">Vorschau 55×71 mm (Hochformat)</div>
          <input id="fileInput-55x71" class="frameFileInput" type="file" accept="image/*" hidden />
          <div id="preview-55x71" class="previewShell" style="width:55mm; height:71mm;">
            <canvas id="canvas-55x71"></canvas>
            <label for="fileInput-55x71" id="dropHint-55x71" class="drop">Bild hierher ziehen oder klicken</label>
          </div>
          <div class="controlBlock">
            <div class="row" style="justify-content:space-between;">
              <span class="label" style="margin:0">Zoom</span>
              <span class="hint" id="zoomLabel-55x71">1.00×</span>
            </div>
            <input id="zoom-55x71" type="range" min="0.1" max="5" step="0.005" value="1" style="width:100%" />
          </div>
          <div class="row buttonRow">
            <button class="btn" data-frame="55x71" data-action="upload">Bild wählen</button>
            <button class="btn" data-frame="55x71" data-action="reset">Zurücksetzen</button>
            <button class="btn" data-frame="55x71" data-action="png">PNG exportieren</button>
          </div>
        </div>

        <div class="card frameCard">
          <div class="frameTitle">Vorschau 71×33 mm (Querformat)</div>
          <input id="fileInput-71x33" class="frameFileInput" type="file" accept="image/*" hidden />
          <div id="preview-71x33" class="previewShell" style="width:71mm; height:33mm;">
            <canvas id="canvas-71x33"></canvas>
            <label for="fileInput-71x33" id="dropHint-71x33" class="drop">Bild hierher ziehen oder klicken</label>
          </div>
          <div class="controlBlock">
            <div class="row" style="justify-content:space-between;">
              <span class="label" style="margin:0">Zoom</span>
              <span class="hint" id="zoomLabel-71x33">1.00×</span>
            </div>
            <input id="zoom-71x33" type="range" min="0.1" max="5" step="0.005" value="1" style="width:100%" />
          </div>
          <div class="row buttonRow">
            <button class="btn" data-frame="71x33" data-action="upload">Bild wählen</button>
            <button class="btn" data-frame="71x33" data-action="reset">Zurücksetzen</button>
            <button class="btn" data-frame="71x33" data-action="png">PNG exportieren</button>
          </div>
        </div>

        <div class="card frameCard">
          <div class="frameTitle">Vorschau 33×71 mm (Hochformat schmal)</div>
          <input id="fileInput-33x71" class="frameFileInput" type="file" accept="image/*" hidden />
          <div id="preview-33x71" class="previewShell" style="width:33mm; height:71mm;">
            <canvas id="canvas-33x71"></canvas>
            <label for="fileInput-33x71" id="dropHint-33x71" class="drop">Bild hierher ziehen oder klicken</label>
          </div>
          <div class="controlBlock">
            <div class="row" style="justify-content:space-between;">
              <span class="label" style="margin:0">Zoom</span>
              <span class="hint" id="zoomLabel-33x71">1.00×</span>
            </div>
            <input id="zoom-33x71" type="range" min="0.1" max="5" step="0.005" value="1" style="width:100%" />
          </div>
          <div class="row buttonRow">
            <button class="btn" data-frame="33x71" data-action="upload">Bild wählen</button>
            <button class="btn" data-frame="33x71" data-action="reset">Zurücksetzen</button>
            <button class="btn" data-frame="33x71" data-action="png">PNG exportieren</button>
          </div>
        </div>
      </div>
    </div>

    <p class="hint" style="margin-top:16px">Quelle: Single‑File ohne Build‑Schritt – ideal für GitHub Pages. Nur diese <code>index.html</code> hochladen.</p>
  </div>

  <script>
    const dpi = 300;
    const mmToInch = (mm) => mm / 25.4;
    const frames = [
      { key: '55x71', mm: { w: 55, h: 71 } },
      { key: '71x33', mm: { w: 71, h: 33 } },
      { key: '33x71', mm: { w: 33, h: 71 } }
    ];

    const fileInput = document.getElementById('fileInput');
    const exportAllPdfBtn = document.getElementById('exportAllPdf');

    const frameStates = frames.map(({ key, mm }) => {
      const preview = document.getElementById(`preview-${key}`);
      const canvas = document.getElementById(`canvas-${key}`);
      const ctx = canvas.getContext('2d');
      const zoom = document.getElementById(`zoom-${key}`);
      const zoomLabel = document.getElementById(`zoomLabel-${key}`);
      const dropHint = document.getElementById(`dropHint-${key}`);
      const frameFileInput = document.getElementById(`fileInput-${key}`);
      const uploadBtn = document.querySelector(`button[data-frame="${key}"][data-action="upload"]`);
      const resetBtn = document.querySelector(`button[data-frame="${key}"][data-action="reset"]`);
      const exportPngBtn = document.querySelector(`button[data-frame="${key}"][data-action="png"]`);
      const px = {
        w: Math.round(mmToInch(mm.w) * dpi),
        h: Math.round(mmToInch(mm.h) * dpi)
      };
      canvas.width = px.w;
      canvas.height = px.h;

      const state = {
        key,
        mm,
        px,
        preview,
        canvas,
        ctx,
        zoom,
        zoomLabel,
        dropHint,
        fileInput: frameFileInput,
        uploadBtn,
        resetBtn,
        exportPngBtn,
        img: null,
        naturalW: 0,
        naturalH: 0,
        offsetX: 0,
        offsetY: 0,
        scale: 1,
        coverScale: 1,
        dragging: false,
        startX: 0,
        startY: 0,
        startOX: 0,
        startOY: 0,
        pointerId: null
      };

      const getLocalPoint = (evt) => {
        const rect = preview.getBoundingClientRect();
        const point = evt.touches ? evt.touches[0] : evt;
        const ratioX = canvas.width / rect.width;
        const ratioY = canvas.height / rect.height;
        return {
          x: (point.clientX - rect.left - rect.width / 2) * ratioX,
          y: (point.clientY - rect.top - rect.height / 2) * ratioY
        };
      };

      const releasePointer = () => {
        state.dragging = false;
        state.pointerId = null;
        updatePreviewCursor(state);
      };

      preview.addEventListener('pointerdown', (evt) => {
        if (!state.img) return;
        if (typeof evt.button === 'number' && evt.button !== 0) return;
        state.dragging = true;
        state.pointerId = evt.pointerId;
        preview.setPointerCapture(evt.pointerId);
        const p = getLocalPoint(evt);
        state.startX = p.x;
        state.startY = p.y;
        state.startOX = state.offsetX;
        state.startOY = state.offsetY;
        updatePreviewCursor(state);
        evt.preventDefault();
      });

      preview.addEventListener('pointermove', (evt) => {
        if (!state.dragging || evt.pointerId !== state.pointerId) return;
        const p = getLocalPoint(evt);
        state.offsetX = state.startOX + (p.x - state.startX);
        state.offsetY = state.startOY + (p.y - state.startY);
        clampOffsets(state);
        drawFrame(state);
        evt.preventDefault();
      });

      preview.addEventListener('pointerup', (evt) => {
        if (evt.pointerId !== state.pointerId) return;
        if (preview.hasPointerCapture(evt.pointerId)) {
          preview.releasePointerCapture(evt.pointerId);
        }
        releasePointer();
      });

      preview.addEventListener('pointercancel', (evt) => {
        if (evt.pointerId !== state.pointerId) return;
        if (preview.hasPointerCapture(evt.pointerId)) {
          preview.releasePointerCapture(evt.pointerId);
        }
        releasePointer();
      });

      preview.addEventListener('lostpointercapture', () => {
        if (!state.dragging) return;
        releasePointer();
      });

      zoom.addEventListener('input', () => {
        setScale(state, parseFloat(zoom.value));
        drawFrame(state);
      });

      preview.addEventListener('wheel', (evt) => {
        if (!state.img) return;
        evt.preventDefault();
        const factor = evt.deltaY > 0 ? 0.9 : 1.1;
        const rect = preview.getBoundingClientRect();
        const pointerX = (evt.clientX - rect.left - rect.width / 2) * (canvas.width / rect.width);
        const pointerY = (evt.clientY - rect.top - rect.height / 2) * (canvas.height / rect.height);
        const prevScale = state.scale;
        const imageRelX = (pointerX - state.offsetX) / prevScale;
        const imageRelY = (pointerY - state.offsetY) / prevScale;
        setScale(state, state.scale * factor);
        state.offsetX = pointerX - imageRelX * state.scale;
        state.offsetY = pointerY - imageRelY * state.scale;
        clampOffsets(state);
        drawFrame(state);
      }, { passive: false });

      resetBtn.addEventListener('click', () => fitCover(state));
      exportPngBtn.addEventListener('click', () => exportPNG(state));
      if (uploadBtn && frameFileInput) {
        uploadBtn.addEventListener('click', () => frameFileInput.click());
      }
      if (frameFileInput) {
        frameFileInput.addEventListener('change', (evt) => {
          const file = evt.target.files && evt.target.files[0];
          if (!file) return;
          loadFileForState(state, file);
          evt.target.value = '';
        });
      }

      ['dragenter', 'dragover'].forEach((ev) => preview.addEventListener(ev, (e) => {
        e.preventDefault();
        if (!dropHint) return;
        dropHint.textContent = 'Loslassen zum Laden…';
        dropHint.style.display = 'grid';
      }));
      ['dragleave', 'dragend', 'drop'].forEach((ev) => preview.addEventListener(ev, (e) => {
        e.preventDefault();
        if (!dropHint) return;
        dropHint.textContent = state.img ? 'Anderes Bild hierher ziehen oder klicken' : 'Bild hierher ziehen oder klicken';
        updateDropHint(state);
      }));
      preview.addEventListener('drop', (e) => {
        const file = e.dataTransfer.files && e.dataTransfer.files[0];
        if (!file) return;
        loadFileForState(state, file);
      });

      return state;
    });

    function setScale(state, nextScale) {
      const min = parseFloat(state.zoom.min);
      const max = parseFloat(state.zoom.max);
      state.scale = Math.min(max, Math.max(min, nextScale));
      state.zoom.value = String(state.scale);
      state.zoomLabel.textContent = state.scale.toFixed(2) + '×';
      clampOffsets(state);
    }

    function clampOffsets(state) {
      if (!state.img) return;
      const halfFrameW = state.px.w / 2;
      const halfFrameH = state.px.h / 2;
      const halfImageW = (state.naturalW * state.scale) / 2;
      const halfImageH = (state.naturalH * state.scale) / 2;
      const limitX = Math.max(0, halfImageW - halfFrameW);
      const limitY = Math.max(0, halfImageH - halfFrameH);
      state.offsetX = Math.min(limitX, Math.max(-limitX, state.offsetX));
      state.offsetY = Math.min(limitY, Math.max(-limitY, state.offsetY));
    }

    function updatePreviewCursor(state) {
      if (!state.preview) return;
      if (!state.img) {
        state.preview.style.cursor = 'default';
      } else {
        state.preview.style.cursor = state.dragging ? 'grabbing' : 'grab';
      }
    }

    function drawFrame(state) {
      const { ctx, canvas } = state;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (state.img) {
        const cx = canvas.width / 2 + state.offsetX;
        const cy = canvas.height / 2 + state.offsetY;
        const drawW = state.naturalW * state.scale;
        const drawH = state.naturalH * state.scale;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(state.img, cx - drawW / 2, cy - drawH / 2, drawW, drawH);
      }
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#222';
      ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
      updatePreviewCursor(state);
    }

    function drawAll() {
      frameStates.forEach(drawFrame);
    }

    function fitCover(state) {
      if (!state.img) return;
      state.coverScale = Math.max(state.px.w / state.naturalW, state.px.h / state.naturalH);
      setScale(state, state.coverScale);
      state.offsetX = 0;
      state.offsetY = 0;
      drawFrame(state);
    }

    function ensureImageLoaded(state) {
      if (!state.img) {
        alert('Bitte zuerst ein Bild für diese Maske laden.');
        return false;
      }
      return true;
    }

    function exportPNG(state) {
      if (!ensureImageLoaded(state)) return;
      const url = state.canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = `maske-${state.mm.w}x${state.mm.h}mm.png`;
      a.click();
    }

    function addCropMarks(pdf, x, y, w, h) {
      const m = 4;
      pdf.line(x - m, y, x, y); pdf.line(x, y - m, x, y);
      pdf.line(x + w, y - m, x + w, y); pdf.line(x + w, y, x + w + m, y);
      pdf.line(x - m, y + h, x, y + h); pdf.line(x, y + h, x, y + h + m);
      pdf.line(x + w, y + h, x + w + m, y + h); pdf.line(x + w, y + h, x + w, y + h + m);
    }

    function exportAllPDF() {
      const loadedStates = frameStates.filter((state) => state.img);
      if (!loadedStates.length) {
        alert('Bitte zuerst mindestens ein Bild laden.');
        return;
      }
      try {
        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) throw new Error('jsPDF nicht geladen');
        const pdf = new jsPDF({ unit: 'mm', format: 'a4' });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const spacing = 12;
        let cursorY = 20;

        loadedStates.forEach((state, index) => {
          const { w, h } = state.mm;
          if (cursorY + h > pageH - 10 && index !== 0) {
            pdf.addPage();
            cursorY = 20;
          }
          const x = (pageW - w) / 2;
          const imgData = state.canvas.toDataURL('image/jpeg', 0.95);
          pdf.setDrawColor(150);
          pdf.setLineWidth(0.2);
          addCropMarks(pdf, x, cursorY, w, h);
          pdf.addImage(imgData, 'JPEG', x, cursorY, w, h);
          cursorY += h + spacing;
        });

        pdf.save('masken-alle.pdf');
      } catch (e) {
        alert('PDF-Export fehlgeschlagen: ' + e.message);
        console.error(e);
      }
    }

    function updateDropHint(state) {
      if (!state.dropHint) return;
      if (state.img) {
        state.dropHint.textContent = 'Anderes Bild hierher ziehen oder klicken';
        state.dropHint.style.display = 'none';
      } else {
        state.dropHint.textContent = 'Bild hierher ziehen oder klicken';
        state.dropHint.style.display = 'grid';
      }
    }

    function updateGlobalButtons() {
      exportAllPdfBtn.disabled = !frameStates.some((state) => state.img);
    }

    function loadDataUrlIntoState(state, dataUrl) {
      const image = new Image();
      image.onload = () => {
        state.img = image;
        state.naturalW = image.naturalWidth;
        state.naturalH = image.naturalHeight;
        state.coverScale = Math.max(state.px.w / state.naturalW, state.px.h / state.naturalH);
        const minS = state.coverScale;
        const maxS = 4 * state.coverScale;
        state.zoom.min = String(minS);
        state.zoom.max = String(maxS);
        state.zoom.step = String(Math.max((maxS - minS) / 200, 0.0005));
        setScale(state, state.coverScale);
        state.offsetX = 0;
        state.offsetY = 0;
        updateDropHint(state);
        drawFrame(state);
        updateGlobalButtons();
      };
      image.onerror = () => {
        alert('Bild konnte nicht geladen werden.');
      };
      image.src = dataUrl;
    }

    function loadFileForState(state, file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        loadDataUrlIntoState(state, ev.target.result);
      };
      reader.readAsDataURL(file);
    }

    function loadFileForAll(file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        const dataUrl = ev.target.result;
        frameStates.forEach((state) => loadDataUrlIntoState(state, dataUrl));
      };
      reader.readAsDataURL(file);
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      loadFileForAll(file);
      e.target.value = '';
    });

    frameStates.forEach((state) => {
      setScale(state, parseFloat(state.zoom.value));
      updateDropHint(state);
    });
    drawAll();
    updateGlobalButtons();
    exportAllPdfBtn.addEventListener('click', exportAllPDF);
  </script>

  <!--
  ▸ Deployment auf GitHub Pages
  1) Neues Repo (z.B. santa3d/bild-maske-55x71)
  2) Diese Datei als index.html ins Repo legen, commit & push
  3) In den Repository-Einstellungen → Pages → Branch: main (root) auswählen
  4) Nach Bereitstellung unter https://<user>.github.io/<repo>/ erreichbar
  -->
</body>
</html>
