<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Runder 48 mm Foto-Designer</title>
  <meta
    name="description"
    content="Einfacher Designer zum Platzieren und Exportieren eines Fotos in einer runden 48 mm-Maske."
  />
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f5f6fa;
      --fg: #0f172a;
      --muted: #64748b;
      --card: rgba(255, 255, 255, 0.92);
      --border: rgba(148, 163, 184, 0.45);
      --accent: #2563eb;
      --accent-dark: #1d4ed8;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at top right, #e2e8ff, var(--bg));
      color: var(--fg);
    }
    header {
      padding: 48px 16px 24px;
      text-align: center;
    }
    h1 {
      margin: 0 0 16px;
      font-size: clamp(32px, 6vw, 44px);
      letter-spacing: -0.02em;
    }
    p.lead {
      max-width: 720px;
      margin: 0 auto;
      color: var(--muted);
      font-size: 18px;
      line-height: 1.6;
    }
    main {
      padding: 0 16px 72px;
    }
    .layout {
      max-width: 1040px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(280px, 320px) minmax(320px, 1fr);
      gap: 24px;
    }
    @media (max-width: 960px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 24px;
      box-shadow: 0 24px 40px -28px rgba(15, 23, 42, 0.35);
      backdrop-filter: blur(6px);
    }
    .card h2 {
      margin-top: 0;
      font-size: 20px;
    }
    label.label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 10px;
    }
    input[type="file"] {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: #fff;
      font-size: 14px;
    }
    .hint {
      margin-top: 12px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }
    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 18px;
    }
    button.btn {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 12px 16px;
      font-weight: 600;
      font-size: 15px;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    button.btn.primary {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 18px 34px -18px rgba(37, 99, 235, 0.6);
    }
    button.btn.primary:hover {
      transform: translateY(-1px);
      background: var(--accent-dark);
    }
    button.btn.secondary {
      background: rgba(255, 255, 255, 0.7);
      color: var(--accent-dark);
      border: 1px solid rgba(37, 99, 235, 0.2);
    }
    button.btn.secondary:hover {
      transform: translateY(-1px);
    }
    .preview-card {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .preview-shell {
      position: relative;
      width: 48mm;
      height: 48mm;
      margin: 0 auto;
      border-radius: 50%;
      border: 2px dashed rgba(37, 99, 235, 0.35);
      background: #fff;
      box-shadow: inset 0 0 0 4px rgba(255, 255, 255, 0.9), 0 20px 36px -28px rgba(30, 64, 175, 0.4);
      overflow: hidden;
      touch-action: none;
      cursor: default;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }
    .drop-hint {
      position: absolute;
      inset: 0;
      display: grid;
      place-content: center;
      text-align: center;
      font-size: 13px;
      color: rgba(15, 23, 42, 0.6);
      padding: 0 14px;
      pointer-events: none;
    }
    .range-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .range-row span {
      font-size: 13px;
      color: var(--muted);
    }
    input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
    }
    .info-list {
      margin: 0;
      padding-left: 18px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.6;
    }
    footer {
      text-align: center;
      padding: 32px 16px 48px;
      color: var(--muted);
      font-size: 14px;
    }
  </style>
  <script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
</head>
<body>
  <header>
    <h1>Designer für runde 48 mm-Fotos</h1>
    <p class="lead">
      Lade ein Motiv, positioniere es in einer hochauflösenden runden Maske und exportiere die perfekte Vorlage
      für Aufkleber, Buttons oder Cover mit 48 mm Durchmesser.
    </p>
  </header>
  <main>
    <div class="layout">
      <section class="card">
        <h2>Bild importieren</h2>
        <label class="label" for="fileInput">Datei wählen</label>
        <input id="fileInput" type="file" accept="image/*" />
        <p class="hint">
          Jede Änderung der Position oder des Zooms wird automatisch in der Vorschau angezeigt. Ziehe das Bild mit der Maus
          oder dem Finger in die gewünschte Position. Mit dem Mausrad oder dem Zoom-Regler passt du die Größe an.
        </p>
        <div class="actions">
          <button id="btnOpen" class="btn secondary" type="button">Neues Bild wählen</button>
          <button id="btnReset" class="btn secondary" type="button" disabled>Bild zentrieren</button>
        </div>
        <div class="actions">
          <button id="btnPng" class="btn primary" type="button" disabled>Als PNG exportieren</button>
          <button id="btnPdf" class="btn primary" type="button" disabled>Als PDF exportieren</button>
        </div>
      </section>

      <section class="card preview-card">
        <div class="preview-shell" id="preview">
          <canvas id="canvas"></canvas>
          <div id="dropHint" class="drop-hint">Bild hierher ziehen oder tippen</div>
        </div>
        <div class="range-row">
          <span>Zoom</span>
          <input id="zoom" type="range" min="0.1" max="5" step="0.005" value="1" />
          <span id="zoomLabel">1.00×</span>
        </div>
        <div class="hint">
          Halte beim Zoomen den Mauszeiger über den interessanten Bereich, damit der Fokus erhalten bleibt. Für einen
          präzisen Druck unbedingt mit 100 % Skalierung drucken.
        </div>
        <ul class="info-list">
          <li>Arbeitsauflösung: 300 DPI &rarr; 48 mm entsprechen 567 × 567 px.</li>
          <li>PNG-Export liefert transparente Ränder außerhalb der Kreisfläche.</li>
          <li>PDF-Export platziert das Motiv mittig auf einer A4-Seite inklusive Schnittkreis.</li>
        </ul>
      </section>
    </div>
  </main>
  <footer>Einfaches Single-File-Tool – ideal für GitHub Pages oder lokale Nutzung.</footer>

  <script>
    const dpi = 300;
    const mmDiameter = 48;
    const mmToInch = (mm) => mm / 25.4;
    const pxSize = Math.round(mmToInch(mmDiameter) * dpi);

    const preview = document.getElementById('preview');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = pxSize;
    canvas.height = pxSize;

    const fileInput = document.getElementById('fileInput');
    const btnOpen = document.getElementById('btnOpen');
    const btnReset = document.getElementById('btnReset');
    const btnPng = document.getElementById('btnPng');
    const btnPdf = document.getElementById('btnPdf');
    const dropHint = document.getElementById('dropHint');
    const zoomInput = document.getElementById('zoom');
    const zoomLabel = document.getElementById('zoomLabel');

    const state = {
      img: null,
      naturalW: 0,
      naturalH: 0,
      scale: 1,
      coverScale: 1,
      offsetX: 0,
      offsetY: 0,
      dragging: false,
      pointerId: null,
      startPointerX: 0,
      startPointerY: 0,
      startOffsetX: 0,
      startOffsetY: 0,
    };

    function updateButtons() {
      const active = Boolean(state.img);
      btnReset.disabled = !active;
      btnPng.disabled = !active;
      btnPdf.disabled = !active;
      zoomInput.disabled = !active;
    }

    function updateZoomLabel() {
      zoomLabel.textContent = state.scale.toFixed(2) + '\u00d7';
    }

    function updateDropHint() {
      if (state.img) {
        dropHint.style.display = 'none';
      } else {
        dropHint.textContent = 'Bild hierher ziehen oder tippen';
        dropHint.style.display = 'grid';
      }
    }

    function clampOffsets() {
      if (!state.img) return;
      const halfFrame = canvas.width / 2;
      const drawW = state.naturalW * state.scale;
      const drawH = state.naturalH * state.scale;
      const halfImageW = drawW / 2;
      const halfImageH = drawH / 2;
      const limitX = Math.max(0, halfImageW - halfFrame);
      const limitY = Math.max(0, halfImageH - halfFrame);
      state.offsetX = Math.min(limitX, Math.max(-limitX, state.offsetX));
      state.offsetY = Math.min(limitY, Math.max(-limitY, state.offsetY));
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.beginPath();
      ctx.arc(0, 0, canvas.width / 2, 0, Math.PI * 2);
      ctx.clip();
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);
      if (state.img) {
        const drawW = state.naturalW * state.scale;
        const drawH = state.naturalH * state.scale;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(
          state.img,
          state.offsetX - drawW / 2,
          state.offsetY - drawH / 2,
          drawW,
          drawH
        );
      }
      ctx.restore();

      ctx.lineWidth = 6;
      ctx.strokeStyle = '#1f2937';
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2 - ctx.lineWidth / 2, 0, Math.PI * 2);
      ctx.stroke();
    }

    function setScale(nextScale) {
      const min = parseFloat(zoomInput.min);
      const max = parseFloat(zoomInput.max);
      state.scale = Math.min(max, Math.max(min, nextScale));
      zoomInput.value = String(state.scale);
      updateZoomLabel();
      clampOffsets();
      draw();
    }

    function fitImage() {
      if (!state.img) return;
      state.coverScale = Math.max(canvas.width / state.naturalW, canvas.height / state.naturalH);
      const minScale = state.coverScale;
      const maxScale = Math.max(4 * state.coverScale, minScale + 0.5);
      zoomInput.min = String(minScale);
      zoomInput.max = String(maxScale);
      zoomInput.step = String(Math.max((maxScale - minScale) / 200, 0.0005));
      state.offsetX = 0;
      state.offsetY = 0;
      setScale(state.coverScale);
    }

    function ensureImage() {
      if (!state.img) {
        alert('Bitte zuerst ein Bild laden.');
        return false;
      }
      return true;
    }

    function exportPNG() {
      if (!ensureImage()) return;
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = canvas.width;
      exportCanvas.height = canvas.height;
      const exportCtx = exportCanvas.getContext('2d');

      exportCtx.save();
      exportCtx.translate(exportCanvas.width / 2, exportCanvas.height / 2);
      exportCtx.beginPath();
      exportCtx.arc(0, 0, exportCanvas.width / 2, 0, Math.PI * 2);
      exportCtx.clip();
      exportCtx.fillStyle = '#ffffff';
      exportCtx.fillRect(-exportCanvas.width / 2, -exportCanvas.height / 2, exportCanvas.width, exportCanvas.height);
      if (state.img) {
        const drawW = state.naturalW * state.scale;
        const drawH = state.naturalH * state.scale;
        exportCtx.imageSmoothingQuality = 'high';
        exportCtx.drawImage(
          state.img,
          state.offsetX - drawW / 2,
          state.offsetY - drawH / 2,
          drawW,
          drawH
        );
      }
      exportCtx.restore();

      exportCtx.globalCompositeOperation = 'destination-in';
      exportCtx.beginPath();
      exportCtx.arc(exportCanvas.width / 2, exportCanvas.height / 2, exportCanvas.width / 2, 0, Math.PI * 2);
      exportCtx.fill();

      const url = exportCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'foto-rund-48mm.png';
      a.click();
    }

    function exportPDF() {
      if (!ensureImage()) return;
      try {
        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) throw new Error('jsPDF nicht verfügbar');
        const pdf = new jsPDF({ unit: 'mm', format: 'a4' });
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const header = 'Bitte mit 100% Skalierung ("Tatsächliche Größe") drucken!';
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.text(header, pageW / 2, 18, { align: 'center' });

        const imgData = canvas.toDataURL('image/png');
        const x = (pageW - mmDiameter) / 2;
        const y = (pageH - mmDiameter) / 2 + 12;
        pdf.addImage(imgData, 'PNG', x, y, mmDiameter, mmDiameter);
        pdf.setDrawColor(60);
        pdf.setLineWidth(0.25);
        pdf.circle(pageW / 2, y + mmDiameter / 2, mmDiameter / 2);
        pdf.save('foto-rund-48mm.pdf');
      } catch (err) {
        alert('PDF-Export fehlgeschlagen: ' + err.message);
        console.error(err);
      }
    }

    function loadDataUrl(dataUrl) {
      const image = new Image();
      image.onload = () => {
        state.img = image;
        state.naturalW = image.naturalWidth;
        state.naturalH = image.naturalHeight;
        fitImage();
        updateDropHint();
        updateButtons();
      };
      image.onerror = () => alert('Bild konnte nicht geladen werden.');
      image.src = dataUrl;
    }

    function handleFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => loadDataUrl(event.target.result);
      reader.readAsDataURL(file);
    }

    function getCanvasPoint(evt) {
      const rect = preview.getBoundingClientRect();
      const point = evt.touches ? evt.touches[0] : evt;
      const ratioX = canvas.width / rect.width;
      const ratioY = canvas.height / rect.height;
      return {
        x: (point.clientX - rect.left) * ratioX,
        y: (point.clientY - rect.top) * ratioY,
      };
    }

    function updateCursor() {
      if (!state.img) {
        preview.style.cursor = 'default';
      } else {
        preview.style.cursor = state.dragging ? 'grabbing' : 'grab';
      }
    }

    preview.addEventListener('pointerdown', (evt) => {
      if (!state.img) return;
      if (typeof evt.button === 'number' && evt.button !== 0) return;
      const p = getCanvasPoint(evt);
      state.startPointerX = p.x - canvas.width / 2;
      state.startPointerY = p.y - canvas.height / 2;
      state.startOffsetX = state.offsetX;
      state.startOffsetY = state.offsetY;
      state.dragging = true;
      state.pointerId = evt.pointerId;
      preview.setPointerCapture(evt.pointerId);
      updateCursor();
      evt.preventDefault();
    });

    preview.addEventListener('pointermove', (evt) => {
      if (!state.dragging || evt.pointerId !== state.pointerId) return;
      const p = getCanvasPoint(evt);
      const relX = p.x - canvas.width / 2;
      const relY = p.y - canvas.height / 2;
      state.offsetX = state.startOffsetX + (relX - state.startPointerX);
      state.offsetY = state.startOffsetY + (relY - state.startPointerY);
      clampOffsets();
      draw();
      evt.preventDefault();
    });

    const releasePointer = (evt) => {
      if (!state.dragging) return;
      if (evt && evt.pointerId !== state.pointerId) return;
      if (state.pointerId !== null && preview.hasPointerCapture(state.pointerId)) {
        preview.releasePointerCapture(state.pointerId);
      }
      state.dragging = false;
      state.pointerId = null;
      updateCursor();
    };

    preview.addEventListener('pointerup', releasePointer);
    preview.addEventListener('pointercancel', releasePointer);
    preview.addEventListener('lostpointercapture', () => {
      if (!state.dragging) return;
      state.dragging = false;
      state.pointerId = null;
      updateCursor();
    });

    preview.addEventListener('wheel', (evt) => {
      if (!state.img) return;
      evt.preventDefault();
      const factor = evt.deltaY > 0 ? 0.9 : 1.1;
      const rect = preview.getBoundingClientRect();
      const pointerX = (evt.clientX - rect.left) * (canvas.width / rect.width) - canvas.width / 2;
      const pointerY = (evt.clientY - rect.top) * (canvas.height / rect.height) - canvas.height / 2;
      const prevScale = state.scale;
      const imageRelX = (pointerX - state.offsetX) / prevScale;
      const imageRelY = (pointerY - state.offsetY) / prevScale;
      setScale(state.scale * factor);
      state.offsetX = pointerX - imageRelX * state.scale;
      state.offsetY = pointerY - imageRelY * state.scale;
      clampOffsets();
      draw();
    }, { passive: false });

    zoomInput.addEventListener('input', () => setScale(parseFloat(zoomInput.value)));
    btnReset.addEventListener('click', () => { fitImage(); });
    btnPng.addEventListener('click', exportPNG);
    btnPdf.addEventListener('click', exportPDF);

    btnOpen.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (evt) => {
      handleFile(evt.target.files && evt.target.files[0]);
      evt.target.value = '';
    });

    ['dragenter', 'dragover'].forEach((eventName) => {
      preview.addEventListener(eventName, (evt) => {
        evt.preventDefault();
        dropHint.textContent = 'Loslassen zum Laden…';
        dropHint.style.display = 'grid';
      });
    });

    ['dragleave', 'dragend', 'drop'].forEach((eventName) => {
      preview.addEventListener(eventName, (evt) => {
        evt.preventDefault();
        updateDropHint();
      });
    });

    preview.addEventListener('drop', (evt) => {
      const file = evt.dataTransfer && evt.dataTransfer.files && evt.dataTransfer.files[0];
      handleFile(file);
    });

    draw();
    updateButtons();
    updateDropHint();
    updateZoomLabel();
    zoomInput.disabled = true;
  </script>
</body>
</html>
